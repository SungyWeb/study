# javascript

1. 自己实现bind

	bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。

	```javascript
	Function.prototype.mybind = function () {
		var thatfn = this;
		var thatArg = arguments[0];
		var args = [].slice.call(arguments, 1);
		if (typeof thatfn !== 'function') {
			throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
		}
		return function () {
			var fnargs = args.concat([].slice.call(arguments));
			return thatfn.apply(thatArg, fnargs);
		}
	}
	var obj = {name:"Smiley"};
	var greeting = function(str, lang){
		this.value = 'greetingValue';
		console.log("Welcome "+this.name+" to "+str+" in "+lang);
		return 'aa';
	};
	var objGreeting = greeting.mybind(obj); 
	var aa = objGreeting('the world','JS');
	console.log(aa);
	```

2. new 操作符

	+ new 一个函数会发生什么
		- 创建一个新对象
		- 将构造函数得作用域赋给新对象（this指向这个新对象）
		- 执行构造函数中得代码（为这个新对象添加属性或方法）
		- 返回新对象
	+ 手动实现new的过程（无法模拟js关键字，使用函数方式）

	```javascript
		function Person(name, age, job) {
		    this.name = name;
		    this.age = age;
		    this.job = job;
		    this.sayName = function() {
		       console.log(this.name)
		    }
		}
		function myNew () {
			var constr = Array.prototype.shift.call(arguments);
			/*
			es5写法
			var obj = {};
			obj.__proto__ = constr.prototype;
			*/
			// es6写法
			var obj = Object.craete(constr.prototype);
			var result = constr.apply(obj, arguments);
			// new这个关键字，并不是所有返回值都原封不动地返回的。如果返回的是undefined，
			// null以及基本类型的时候，都会返回新的对象；
			// 而只有返回对象的时候，才会返回构造函数的返回值。
			// 此处要考虑constr是否有返回值
			return result instanceof Object ? result : obj;
		}
		var person = myNew(Person, 'aa', 'bb', 'cc');
	```

3. 实现call/apply

	apply方法传入两个参数，第一个参数就是this的指向，第二个参数就是函数参数组成的数组；而call传入多个参数，第一个参数也是this的指向，之后的参数都是函数的参数

	```javascript
	// 例子
	var person = {
		fullName: function(txt) {
			console.log(txt + this.firstName + " " + this.lastName);
		}
	}
	var person1 = {
		firstName:"John",
		lastName: "Doe"
	} 
	person.fullName.call(person1, "Hello, ");  // 输出"Hello, John Doe"
	```

	```javascript
	Function.prototype.myCall = function (context) {
		// 如果call的第一个参数是null，this会指向window
		context = context || window;
		var uniqueID = 'fn' + Math.random();
		while (context.hasOwnProperty(uniqueID)) {
			uniqueID = 'fn' + Math.random();
		}
		context[uniqueID] = this;
		var args = Array.from(arguments).slice(1);
		var result = context[uniqueID](...args);
		delete context[uniqueID];
		return result;
	}
	person.fullName.myCall(person1, 'aaa');
	```

	```javascript
	Function.prototype.myApply = function (context, arr) {
		context = context || window;
		var uniqueID = 'fn' + Math.random();
		while (context.hasOwnProperty(uniqueID)) {
			uniqueID = 'fn' + Math.random();
		}
		context[uniqueID] = this;
		var result = context[uniqueID](...arr);
		delete context[uniqueID];
		return result;
	}
	person.fullName.myApply(person1, ['aaa']);
	```
