# javascript

1. 自己实现bind

	bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。

	```javascript
	Function.prototype.mybind = function () {
		var thatfn = this;
		var thatArg = arguments[0];
		var args = [].slice.call(arguments, 1);
		if (typeof thatfn !== 'function') {
			throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
		}
		return function () {
			var fnargs = args.concat([].slice.call(arguments));
			return thatfn.apply(thatArg, fnargs);
		}
	}
	var obj = {name:"Smiley"};
	var greeting = function(str, lang){
		this.value = 'greetingValue';
		console.log("Welcome "+this.name+" to "+str+" in "+lang);
		return 'aa';
	};
	var objGreeting = greeting.mybind(obj); 
	var aa = objGreeting('the world','JS');
	console.log(aa);
	```

2. new 操作符

	+ new 一个函数会发生什么
		- 创建一个新对象
		- 将构造函数得作用域赋给新对象（this指向这个新对象）
		- 执行构造函数中得代码（为这个新对象添加属性或方法）
		- 返回新对象
	+ 手动实现new的过程（无法模拟js关键字，使用函数方式）

	```javascript
	function Person(name, age, job) {
		this.name = name;
		this.age = age;
		this.job = job;
		this.sayName = function() {
			console.log(this.name)
		}
	}
	function myNew () {
		var constr = Array.prototype.shift.call(arguments);
		/*
		es5写法
		var obj = {};
		obj.__proto__ = constr.prototype;
		*/
		// es6写法
		var obj = Object.craete(constr.prototype);
		var result = constr.apply(obj, arguments);
		// new这个关键字，并不是所有返回值都原封不动地返回的。如果返回的是undefined，
		// null以及基本类型的时候，都会返回新的对象；
		// 而只有返回对象的时候，才会返回构造函数的返回值。
		// 此处要考虑constr是否有返回值
		return result instanceof Object ? result : obj;
	}
	var person = myNew(Person, 'aa', 'bb', 'cc');
	```

3. 实现call/apply

	apply方法传入两个参数，第一个参数就是this的指向，第二个参数就是函数参数组成的数组；而call传入多个参数，第一个参数也是this的指向，之后的参数都是函数的参数

	```javascript
	// 例子
	var person = {
		fullName: function(txt) {
			console.log(txt + this.firstName + " " + this.lastName);
		}
	}
	var person1 = {
		firstName:"John",
		lastName: "Doe"
	} 
	person.fullName.call(person1, "Hello, ");  // 输出"Hello, John Doe"
	```

	```javascript
	Function.prototype.myCall = function (context) {
		// 如果call的第一个参数是null，this会指向window
		context = context || window;
		var uniqueID = 'fn' + Math.random();
		while (context.hasOwnProperty(uniqueID)) {
			uniqueID = 'fn' + Math.random();
		}
		context[uniqueID] = this;
		var args = Array.from(arguments).slice(1);
		var result = context[uniqueID](...args);
		delete context[uniqueID];
		return result;
	}
	person.fullName.myCall(person1, 'aaa');
	```

	```javascript
	Function.prototype.myApply = function (context, arr) {
		context = context || window;
		var uniqueID = 'fn' + Math.random();
		while (context.hasOwnProperty(uniqueID)) {
			uniqueID = 'fn' + Math.random();
		}
		context[uniqueID] = this;
		var result = context[uniqueID](...arr);
		delete context[uniqueID];
		return result;
	}
	person.fullName.myApply(person1, ['aaa']);
	```

4. this

	四种this绑定是基于调用者分类，即函数在哪里被调用，this就指向谁，与函数在哪里定义没有关系

	+ 默认绑定与隐式绑定

		```javascript
		function foo() { 
			console.log(this.bar); 
		} 
		var bar = "bar1"; 
		var o2 = {bar: "bar2", foo: foo}; 
		var o3 = {bar: "bar3", foo: foo}; 
		foo();            // "bar1" – 默认绑定
		o2.foo();          // "bar2" – 隐式绑定
		o3.foo();          // "bar3" – 隐式绑定
		```

		foo()这种调用方法，就是默认绑定。如果在非严格模式下，this就是全局对象，浏览器当中就是window。而如果在严格模式（use strict）下，this就会是undefined。

	+ 显示绑定

		```javascript
		function foo() { 
			console.log(this.bar); 
		} 
		var bar = "bar1"; 
		var obj = {bar: "bar2"}; 
		foo();          // "bar1"   默认绑定
		foo.call(obj);     // "bar2"  显式绑定，使用obj作为"this" 
		```

		如果foo是通过call、apply或者bind调用的，那么这种调用就是显式绑定。这种绑定中,this的指向就是这三个函数中传递的第一个参数

	+ 关键字new绑定

		```javascript
		function foo() { 
			this.baz = "baz"; 
			console.log(this.bar + " " + baz); 
		}
		var bar = "bar"; 
		var baz = new foo(); 
		```

	+ 箭头函数

		箭头函数会无视以上所有的规则，this的值就是函数创建时候所在的对象，而不是调用时的函数对象

		```javascript
		function Person(){
			this.age = 10;
			setTimeout(()=> {
				console.log(this.age);     // 输出10
			}, 1000);
		}
		var p = new Person();
		```
