<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script src="../js/three.js"></script>
  <script src="../js/controls/OrbitControls.js"></script>
  <script>
    // 创建场景
    var scene = new THREE.Scene();
    // 网格模型
      // 立方体
    var box = new THREE.BoxGeometry(50, 50, 50);   // 几何体
    var material = new THREE.MeshLambertMaterial({
      color: 0x11aaff,
      opacity: 0.7,
      transparent: true,
    });  // 材质
    var mesh = new THREE.Mesh(box, material);   // 网格模型
    scene.add(mesh);  // 将网格模型添加到场景中
      // 球
    var sphere = new THREE.SphereGeometry(25,40,40); // 创建一个球体
    var sphereMaterial = new THREE.MeshLambertMaterial({
      color: 0x0000ff,
      opacity: 0.7,
      transparent: true,
    });  // 材质 透视
    var phongMaterial = new THREE.MeshPhongMaterial({
      color: 0x0000ff,
      specular: 0x4488ee,
      shininess: 12,
    });  // 材质 高亮
    // var mesh2 = new THREE.Mesh(sphere,sphereMaterial);  // 透视
    var mesh2 = new THREE.Mesh(sphere,phongMaterial);   // 高亮
    mesh2.translateY(50);   // 移动
    scene.add(mesh2);
    // 创建线条对象
    var lineGeometry = new THREE.Geometry();    // 空几何体
    var p1 = new THREE.Vector3(0, 0, 0);   // 顶点1坐标
    var p2 = new THREE.Vector3(300, 0, 0);   // 顶点2坐标
    var p3 = new THREE.Vector3(0, 0, 0);   // 顶点3坐标
    var p4 = new THREE.Vector3(0, 300, 0);   // 顶点4坐标
    var p5 = new THREE.Vector3(0, 0, 0);   // 顶点4坐标
    var p6 = new THREE.Vector3(0, 0, 300);   // 顶点4坐标
    lineGeometry.vertices.push(p1, p2, p3, p4, p5, p6);    // 将顶点添加到几何体
    var lineMaterial = new THREE.LineBasicMaterial({
        color: 0xff0000
    });     // 材质对象
    var line = new THREE.Line(lineGeometry, lineMaterial);      // 线条模型对象
    scene.add(line);    // 将线条模型添加到场景中
    // 创建点对象
    var pointGeometry = new THREE.Geometry();
    var p7 = new THREE.Vector3(100, 0, 0);   // 顶点1坐标
    var p8 = new THREE.Vector3(0, 120, 0);   // 顶点2坐标
    var p9 = new THREE.Vector3(115, 115, 0);   // 顶点3坐标
    pointGeometry.vertices.push(p7, p8, p9);    // 将顶点添加到几何体
    var pointMaterial = new THREE.PointsMaterial({
      color: 0xff0000,
      size: 10
    });
    var points = new THREE.Points(pointGeometry, pointMaterial);
    scene.add(points);
    // 光源设置
    var point = new THREE.PointLight(0xffffff);   // 点光源
    point.position.set(400, 200, 300);    // 光源位置
    scene.add(point);   // 将点光源添加到场景中
    var ambient = new THREE.AmbientLight(0x444444);   // 环境光
    scene.add(ambient);   // 将环境光添加到场景中
    // 相机设置
    var width = window.innerWidth, height = window.innerHeight;
    var k = width / height;   // 窗口宽高比
    var s = 100;    // 三维场景缩放系数
    var camera = new THREE.OrthographicCamera(-s*k,s*k,s,-s,1,1000);    // 创建相机
    camera.position.set(200, 300, 200);   // 相机位置
    camera.lookAt(scene.position);    // 设置相机方向，指向场景的方向
    // 创建渲染器
    var render = new THREE.WebGLRenderer();   // 创建渲染器
    render.setSize(width, height);    // 设置大小
    render.setClearColor(0xb9d3ff, 1);    // 背景色
    document.body.appendChild(render.domElement);   // body中插入canvas对象
    
    /*
    在实际执行程序的时候，可能requestAnimationFrame(render)请求的函数并不一定能按照理想的60FPS频率执行，
    两次执行渲染函数的时间间隔也不一定相同， 如果执行旋转命令的rotateY的时间间隔不同，旋转运动就不均匀，
    为了解决这个问题需要通过程序记录两次执行绘制函数的时间间隔。

    使用下面的渲染函数替换原来的渲染函数即可，rotateY()的参数是0.001*t，
    也意味着两次调用渲染函数执行渲染操作的间隔t毫秒时间内，立方体旋转了0.001*t弧度，
    很显然立方体的角速度是0.001弧度每毫秒(0.0001 rad/ms = 1 rad/s = 180度/s)。
    CPU和GPU执行一条指令时间是纳秒ns级，相比毫秒ms低了6个数量级，
    所以一般不用考虑渲染函数中几个计时语句占用的时间，除非你编写的是要精确到纳秒ns的级别的标准时钟程序。
    */
    // 动画
    var t0 = new Date();
    function renderFn() {
      var t1 = new Date();
      var t = t1 - t0;
      t0 = t1;
      // 执行渲染
      render.render(scene, camera);
      mesh.rotateY(0.001 * t);
      requestAnimationFrame(renderFn);
    }
    renderFn();

    // 鼠标动作 需要OribtControls.js
    // todo：暂时没有鼠标---待确认
    // function renderFn() {
    //   render.render(scene, camera);
    // }
    // renderFn();
    // var control = new THREE.OrbitControls(camera);    // 创建控件对象
    // control.addEventListener('change', renderFn);
  </script>
</body>
</html>