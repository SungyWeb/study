<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script src="../js/three.js"></script>
  <script src="../js/controls/OrbitControls.js"></script>
  <script>
    // 创建场景
    var scene = new THREE.Scene();
    // 网格模型
    var box = new THREE.BoxGeometry(100, 100, 100);   // 几何体
    var material = new THREE.MeshLambertMaterial({color: 0x11aaff});  // 材质
    var mesh = new THREE.Mesh(box, material);   // 网格模型
    scene.add(mesh);  // 将网格模型添加到场景中
    var sphere = new THREE.SphereGeometry(50,40,40); // 创建一个球体
    var sphereMaterial = new THREE.MeshLambertMaterial({
      color: 0x0000ff,
      opacity: 0.7,
      transparent: true,
    });  // 材质
    var sphereMaterial = new THREE.MeshPhongMaterial({
      color: 0x0000ff,
      specular: 0x4488ee,
      shininess: 12,
    });
    var mesh2 = new THREE.Mesh(sphere,sphereMaterial);
    mesh2.translateY(50);   // 移动
    
    scene.add(mesh2);
    // 光源设置
    var point = new THREE.PointLight(0xffffff);   // 点光源
    point.position.set(400, 200, 300);    // 光源位置
    scene.add(point);   // 将点光源添加到场景中
    var ambient = new THREE.AmbientLight(0x444444);   // 环境光
    scene.add(ambient);   // 将环境光添加到场景中
    // 相机设置
    var width = window.innerWidth, height = window.innerHeight;
    var k = width / height;   // 窗口宽高比
    var s = 100;    // 三维场景缩放系数
    var camera = new THREE.OrthographicCamera(-s*k,s*k,s,-s,1,1000);    // 创建相机
    camera.position.set(200, 300, 200);   // 相机位置
    camera.lookAt(scene.position);    // 设置相机方向，指向场景的方向
    // 创建渲染器
    var render = new THREE.WebGLRenderer();   // 创建渲染器
    render.setSize(width, height);    // 设置大小
    render.setClearColor(0xb9d3ff, 1);    // 背景色
    document.body.appendChild(render.domElement);   // body中插入canvas对象
    
    /*
    在实际执行程序的时候，可能requestAnimationFrame(render)请求的函数并不一定能按照理想的60FPS频率执行，
    两次执行渲染函数的时间间隔也不一定相同， 如果执行旋转命令的rotateY的时间间隔不同，旋转运动就不均匀，
    为了解决这个问题需要通过程序记录两次执行绘制函数的时间间隔。

    使用下面的渲染函数替换原来的渲染函数即可，rotateY()的参数是0.001*t，
    也意味着两次调用渲染函数执行渲染操作的间隔t毫秒时间内，立方体旋转了0.001*t弧度，
    很显然立方体的角速度是0.001弧度每毫秒(0.0001 rad/ms = 1 rad/s = 180度/s)。
    CPU和GPU执行一条指令时间是纳秒ns级，相比毫秒ms低了6个数量级，
    所以一般不用考虑渲染函数中几个计时语句占用的时间，除非你编写的是要精确到纳秒ns的级别的标准时钟程序。
    */
    // 动画
    // var t0 = new Date();
    // function renderFn() {
    //   var t1 = new Date();
    //   var t = t1 - t0;
    //   t0 = t1;
    //   // 执行渲染
    //   render.render(scene, camera);
    //   mesh.rotateY(0.001 * t);
    //   requestAnimationFrame(renderFn);
    // }
    // renderFn();

    // 鼠标动作 需要OribtControls.js
    // todo：暂时没有鼠标---待确认
    function renderFn() {
      render.render(scene, camera);
    }
    renderFn();
    var control = new THREE.OrbitControls(camera);    // 创建控件对象
    control.addEventListener('change', renderFn);
  </script>
</body>
</html>